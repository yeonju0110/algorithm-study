# 📝 문제 풀이 보고서 
> [매출 하락 최소화](https://school.programmers.co.kr/learn/courses/30/lessons/72416)

## ⏱️ 문제 풀이 시간
- 총 소요 시간: **180분**

---

## 📊 문제 난이도
- [ ] 🟢 쉬움
- [ ] 🟡 보통
- [x] 🔴 어려움

---

## ⚙️ 사용한 알고리즘
- 트리 dp

---

## 💡 풀이 과정 (생각의 흐름)
### 1단계: 첫 번째 시도
1. 조합으로 해도 시간 초과가 안나려나?
   - 초기 아이디어: 팀별로 한 명의 사람을 뽑는 모든 경우의 수를 곱해서 계산
   - 문제점 분석:
     - 직원 수는 최대 300,000명
     - 각 팀원은 최대 2개 팀에 속할 수 있음
   - 시간복잡도: 각 팀마다 선택지가 여러 개 → 지수적 증가
   - 결론: 확실히 시간초과! 다른 방법 필요


2. CEO는 무조건 1번이니까 1번이 속한 팀부터 누굴 참가시킬지 뽑아보자
   - 시도한 그리디 접근:
     - CEO(1번)부터 시작해서 각 팀에서 가장 저렴한 직원 선택
     - 문제점: 지역 최적해만 구할 수 있음
     - 결론: 최적해 보장 안될 것 같음.


3. Leaf node부터 올라오면서 구해보자
   - 트리 구조이므로 Bottom-up 접근이 가능
   - 작은 문제(서브트리)의 최적해를 구해서 큰 문제 해결
   - 구체적인 접근 계획:
     - 리프 노드부터 시작 (가장 작은 서브트리)
     - 각 노드에서 "선택 vs 미선택" 두 가지 상태 관리 (*상태관리는 클로드한테 힌트 얻음ㅠㅠ)
     - 부모 노드에서 자식들의 결과를 활용해 최적해 계산 
     - 최종적으로 루트에서 전체 최적해 도출

![IMG_36BE9710487E-1.jpeg](/images/pro72416.jpeg)

4. 어떻게 계산하지? ㅠㅠ 차근차근 해보자
    ```
    DP 상태 정의 고민:
    dp[node][0] = node를 선택했을 때, node 서브트리의 모든 팀을 커버하는 최소비용
    dp[node][1] = node를 선택하지 않았을 때, node 서브트리의 모든 팀을 커버하는 최소비용
    
    리프 노드 처리:
    dp[leaf][0] = sales[leaf] (리프 선택)
    dp[leaf][1] = 0 (리프는 팀원이므로 선택 안해도 됨)
    
    내부 노드 처리:
    dp[node][0]: 현재 노드 선택 → 자식들은 자유롭게 선택
    dp[node][1]: 현재 노드 미선택 → 현재 팀을 커버하기 위해 자식 중 최소 1명은 선택
    ```

    ```python
    def solution(sales, links):
        # 길이 보정 (1부터 시작하도록)
        sales = [0] + sales
        n = len(sales)
        
        # 그래프 초기화
        graph = [[] for _ in range(n)]
        dp = [[0, 0] for _ in range(n)]
        
        # links 배열을 순회하며 그래프 구성
        for link in links:
            from_node, to_node = link
            graph[from_node].append(to_node)
        
        # 방문 여부
        visited = [False] * n
        
        # DFS 호출
        dfs(1, sales, graph, visited, dp)
        
        return min(dp[1][0], dp[1][1])
    
    def dfs(node, sales, graph, visited, dp):
        # 현재 노드 방문 처리
        visited[node] = True
        
        if not graph[node]:  # 리프 노드
            dp[node][0] = sales[node]  # 선택
            dp[node][1] = 0  # 선택안함 (팀원이므로 선택 안해도 됨)
            return
        
        # 자식들 먼저 처리
        for child in graph[node]:
            if not visited[child]:
                dfs(child, sales, graph, visited, dp)
        
        # 현재 노드 선택시: 자식들은 자유롭게 선택
        dp[node][0] = sales[node]
        for child in graph[node]:
            dp[node][0] += min(dp[child][0], dp[child][1])
        
        # 현재 노드 미선택시: 자식 중 최소 1명은 반드시 선택되어야 함
        dp[node][1] = float('inf')
        
        for child in graph[node]:
            # 이 자식을 선택하고, 나머지는 최적으로
            cost = dp[child][0]  # 이 자식은 반드시 선택
            for other_child in graph[node]:
                if other_child != child:
                    cost += min(dp[other_child][0], dp[other_child][1])
            
            dp[node][1] = min(dp[node][1], cost)
    ```

5. 코드를 작성하니 통과O. 그러나 시간 복잡도 O(n²)
   - 문제점 발견:
     - 각 내부 노드에서 이중 루프 발생 
     - 자식 수가 많은 노드에서 O(자식수²) 시간 소요 
     - 최악의 경우: 한 노드가 (n-1)개 자식을 가지면 O(n²)
     - 300,000개 노드 → 9×10¹⁰ 연산 → 시간초과 위험

### 2단계: 최적화
- 전체 합 = 모든 자식의 최솟값 합
- 한 자식을 "선택"으로 바꿀 때의 추가 비용만 계산 => O(n)
- 최종 답 = 전체 합 + 최소 추가비용

```python
def solution(sales, links):
    # 길이 보정 (1부터 시작하도록)
    sales = [0] + sales
    n = len(sales)
    
    # 그래프 초기화
    graph = [[] for _ in range(n)]
    dp = [[0, 0] for _ in range(n)]
    
    # links 배열을 순회하며 그래프 구성
    for link in links:
        from_node, to_node = link
        graph[from_node].append(to_node)
    
    # 방문 여부
    visited = [False] * n
    
    # DFS 호출
    dfs(1, sales, graph, visited, dp)
    
    return min(dp[1][0], dp[1][1])

def dfs(node, sales, graph, visited, dp):
    # 현재 노드 방문 처리
    visited[node] = True
    
    if not graph[node]:  # 리프 노드
        dp[node][0] = sales[node]  # 선택
        dp[node][1] = 0  # 선택안함
        return
    
    # 자식들 먼저 처리
    for child in graph[node]:
        if not visited[child]:
            dfs(child, sales, graph, visited, dp)
    
    # 현재 노드 선택시: 자식들은 자유롭게 선택
    dp[node][0] = sales[node]
    for child in graph[node]:
        dp[node][0] += min(dp[child][0], dp[child][1])
    
    # 현재 노드 미선택시: 자식 중 최소 1명은 반드시 선택되어야 함
    
    # 🚀 최적화: (전체 합을 미리 계산 - 각자를 선택으로 바꾸는 비용)
    total_sum = 0
    min_extra_cost = float('inf')
    
    for child in graph[node]:
        child_min = min(dp[child][0], dp[child][1])
        total_sum += child_min
        
        # 이 자식을 "선택"으로 바꿀 때의 추가 비용
        extra_cost = dp[child][0] - child_min
        min_extra_cost = min(min_extra_cost, extra_cost)
    
    dp[node][1] = total_sum + min_extra_cost
```

## 😢 회고
### 이런 문제 유형(트리 DP)을 어떻게 알아볼까?

#### 📋 핵심 키워드 체크리스트
1. **구조적 특징**
   - ✅ **"팀장-팀원 관계"** → 계층 구조
   - ✅ **"CEO가 1번 고정"** → 루트가 명확한 트리
   - ✅ **"각 직원이 정확히 1개의 화살표를 받음"** → 트리 구조 확증
   - ✅ **"조직도", "상하관계", "부모-자식"** 등의 용어

2. **제약 조건**
   - ✅ **"모든 팀에서 최소 1명"** → 각 서브트리마다 조건
   - ✅ **"최소/최대 비용"** → 최적화 문제
   - ✅ **"선택 vs 미선택"** → 이진 상태

3. **데이터 크기**
   - ✅ **N ≤ 300,000** → O(n²) 불가, O(n) 또는 O(n log n) 필요

#### 🎯 문제 유형별 판별 가이드

- **트리 DP 확신 시그널**
    ```
    IF (계층구조 + 각 노드마다 조건 + 최적화)
       AND (전체 답이 부분 최적해에 의존)
       THEN 트리 DP
    ```

- **유사 문제 패턴들**
  1. **"회사 조직에서 교육 참석자 선정"**
  2. **"트리에서 정점 선택하여 모든 간선 커버"**
  3. **"가족 관계에서 모임 참석자 결정"**
  4. **"네트워크에서 서버 배치"**

#### 📚 트리 DP 문제 유형 분류

- **Type 1: 정점 선택 문제**
    ```
    - 각 노드를 선택/미선택
    - 특정 조건 하에서 비용 최적화
    - dp[node][선택여부] 패턴
    ```
    - **예시:** 이 문제, 독립집합, 정점 커버

- **Type 2: 서브트리 통계 문제**
    ```
    - 각 서브트리의 특성 계산
    - 거리, 개수, 합계 등
    - dp[node] = f(자식들의 dp값)
    ```
    - **예시:** 트리의 지름, 서브트리 크기

- **Type 3: 경로 최적화 문제**
    ```
    - 루트에서 리프까지의 경로
    - 최대/최소 경로 비용
    - dp[node] = 현재까지 최적값
    ```
    - **예시:** 트리에서 최장 경로

#### 🚨 함정 피하기

- **트리 DP가 아닌 경우들**
    ```
    ❌ 그래프가 사이클을 가짐 → 일반 DP 또는 다른 알고리즘
    ❌ 순서가 중요함 → 순열/조합 문제
    ❌ 동적으로 구조가 변함 → 동적 자료구조
    ❌ 전역 조건이 복잡함 → 백트래킹 또는 특수 알고리즘
    ```

#### 💡 빠른 판별 체크리스트

```
1. 입력이 트리 구조인가? (N개 노드, N-1개 간선)
2. 각 노드마다 독립적인 선택이 있는가?
3. 부분 문제의 최적해가 전체 최적해에 기여하는가?
4. Bottom-up으로 해결 가능한가?

4개 모두 YES → 트리 DP 99% 확신!
```

#### 🔧 접근 전략

- **1단계: 문제 변환**
  - 문제를 트리 구조로 모델링
  - 각 노드의 상태 정의

-  **2단계: 점화식 도출**
  - 리프 노드 base case
    - 내부 노드 recurrence relation

- **3단계: 구현 최적화**
  - DFS 순회 방식
  - 메모리/시간 복잡도 고려
