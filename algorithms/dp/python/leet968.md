# 📝 문제 풀이 보고서 
> [Binary Tree Cameras](https://leetcode.com/problems/binary-tree-cameras/description/?page=1&topicSlugs=dynamic-programming)

## ⏱️ 문제 풀이 시간
- 총 소요 시간: **80분**

---

## 📊 문제 난이도
- [ ] 🟢 쉬움
- [x] 🟡 보통
- [ ] 🔴 어려움

---

## ⚙️ 사용한 알고리즘
- **트리 DP (Tree Dynamic Programming)**
- **후위 순회 (Postorder Traversal)**
- **탐욕적 접근 (Greedy)** - 리프의 부모에 카메라를 우선 배치

---

## 💡 풀이 과정 (생각의 흐름)

### 1단계: 문제 이해
- 카메라는 자신, 부모, 자식을 감시 가능
- 모든 노드를 감시하는 최소 카메라 개수 구하기
- **핵심 인사이트**: 리프 노드보다 그 부모에 카메라를 놓는 게 효율적!

### 2단계: 접근 방법 선택

#### 첫 번째 시도: 2가지 상태로 접근 (실패)
- **Bottom-up DP**: 리프부터 시작해서 위로 올라가며 결정
- 처음에는 "카메라 있음/없음" 2가지 상태만 생각
  - `dp[i][0] = 카메라 없을 때 최소 개수`
  - `dp[i][1] = 카메라 있을 때 최소 개수`

**❌ 왜 안 됐을까?**
- "카메라 없음" 상태가 **두 가지 의미**를 가짐
  1. 카메라는 없지만 **자식의 카메라로 이미 감시됨** (안전)
  2. 카메라도 없고 **아직 감시 안됨** (위험!)
- 부모 노드 입장에서 이 두 경우를 구분해야 올바른 결정 가능
- 예시:
  ```
      A (부모)
     /
    B (카메라 없음)
  ```
  - B가 "안전한 없음"이면 → A는 선택 가능
  - B가 "위험한 없음"이면 → A는 반드시 카메라 설치!

#### 두 번째 시도: 3가지 상태로 재설계,,
각 노드는 3가지 상태 중 하나
- `NEED_COVER (0)`: 아직 감시 안됨 (위험!)
- `HAS_CAMERA (1)`: 카메라 설치됨
- `COVERED (2)`: 감시되고 있음 (카메라는 없음)

**✅ 왜 이제 됐을까?**
- "카메라 없음"을 `NEED_COVER`와 `COVERED`로 분리
- 부모가 자식 상태를 보고 명확한 결정 가능
- 각 상태가 하나의 의미만 가짐

### 3단계: 상태 전이 로직

| 왼쪽 자식 | 오른쪽 자식 | 현재 노드 상태 | 카메라 설치 | 이유 |
|---------|-----------|-------------|----------|------|
| NEED_COVER | * | **HAS_CAMERA** | ✅ +1 | 자식이 위험하면 즉시 설치 |
| * | NEED_COVER | **HAS_CAMERA** | ✅ +1 | 자식이 위험하면 즉시 설치 |
| HAS_CAMERA | HAS_CAMERA | **COVERED** | ❌ | 양쪽 자식 카메라가 감시 |
| HAS_CAMERA | COVERED | **COVERED** | ❌ | 왼쪽 카메라가 감시 |
| COVERED | HAS_CAMERA | **COVERED** | ❌ | 오른쪽 카메라가 감시 |
| COVERED | COVERED | **NEED_COVER** | ❌ | 탐욕: 부모에게 책임 전가 |


### 4단계: 특수 케이스 처리
- **None 노드**: `COVERED`로 처리 (리프가 위험 상태가 되도록)
- **Root 노드**: DFS 후 `NEED_COVER` 상태면 카메라 추가

```python
class Solution:
    def minCameraCover(self, root: Optional[TreeNode]) -> int:
        # 노드의 3가지 상태 정의
        NEED_COVER = 0  # 감시 필요 (위험 상태)
        HAS_CAMERA = 1  # 카메라 설치됨
        COVERED = 2     # 감시되고 있음 (카메라는 없음)
        
        self.cameras = 0  # 설치한 카메라 개수
        
        def dfs(node):
            # 베이스 케이스: None 노드는 감시된 것으로 처리
            # → 리프 노드가 NEED_COVER 상태가 되도록 유도
            if not node:
                return COVERED
            
            # 자식 노드들의 상태를 먼저 확인 (후위 순회)
            left = dfs(node.left)
            right = dfs(node.right)
            
            # 우선순위 1: 자식이 하나라도 위험하면 현재 노드에 카메라 설치
            # → 부모보다 자식에 가까운 곳에 설치하는 게 효율적
            if left == NEED_COVER or right == NEED_COVER:
                self.cameras += 1
                return HAS_CAMERA
            
            # 우선순위 2: 자식에 카메라가 있으면 현재 노드는 감시됨
            # → 자식의 카메라가 현재 노드를 커버
            elif left == HAS_CAMERA or right == HAS_CAMERA:
                return COVERED
            
            # 우선순위 3: 자식들이 모두 COVERED 상태
            # → 현재 노드는 감시 필요 (탐욕: 부모에게 책임 전가)
            # → 리프보다 부모에 카메라를 놓는 게 효율적
            else:
                return NEED_COVER
        
        # Root 특수 처리: root가 감시 안됐으면 카메라 추가
        # → root 위에는 부모가 없으므로 직접 카메라 설치 필요
        if dfs(root) == NEED_COVER:
            self.cameras += 1
        
        return self.cameras
```


### 📈 복잡도 분석
- **시간 복잡도**: O(N) - 모든 노드를 한 번씩 방문
- **공간 복잡도**: O(H) - 재귀 스택 (H = 트리 높이, 최악 O(N))

---

## 🎓 핵심 인사이트

### 1. 트리 DP의 상태 설계 ⭐️
- 단순히 "있다/없다" 2가지가 아닌, **문제 맥락에 맞는 상태** 정의가 핵심
- 이 문제에서는 "카메라 없음"이 두 가지 의미를 가짐을 발견
  - 안전하게 감시됨 (`COVERED`)
  - 위험하게 방치됨 (`NEED_COVER`)

### 2. 탐욕적 관찰
- **리프보다 부모에 카메라를 배치**하는 게 효율적
- 한 카메라가 3개 노드(자신, 부모, 자식)를 커버하므로 위쪽이 유리

### 3. 특수 케이스 처리 패턴
- **None 노드**: `COVERED`로 설정 → 리프가 `NEED_COVER` 상태가 되도록 유도
- **Root 노드**: DFS 종료 후 `NEED_COVER` 상태면 카메라 추가 필요

---

## 😢 회고

### ✅ 잘한 점
- Bottom-up 접근법을 빠르게 선택
- 첫 시도 실패 후 상태를 재설계하여 해결

### ❌ 실수했던 부분
1. **상태 설계 미흡**: 처음에 2가지 상태만 고려 → "카메라 없음"의 중의성 간과
2. **베이스 케이스 고민**: None 노드를 어떤 상태로 처리할지 혼란
3. **루트 예외 처리**: DFS 후 root가 `NEED_COVER`인 경우를 놓칠 뻔함

### 📝 다음에 주의할 점
- **상태 정의 먼저**: 코드 작성 전에 모든 가능한 상태와 의미 명확히 정리
- **상태 전이 표 작성**: 자식 상태 조합별 현재 노드 결정을 표로 시각화
- **엣지 케이스 체크리스트**: 단일 노드, None, Root를 습관적으로 확인

### 🎯 이런 문제를 만나면?

**트리 DP 패턴 인식 신호:**
- ✅ "최소/최대" 최적화 문제
- ✅ 부모-자식 간 의존성 (한 노드의 결정이 다른 노드에 영향)
- ✅ 전체를 한 번에 결정할 수 없고, 부분 문제 분할 필요
- ✅ "각 노드에서 선택"의 개념 존재
