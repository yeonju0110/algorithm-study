# 📝 문제 풀이 보고서 
> [주사위 고르기](https://school.programmers.co.kr/learn/courses/30/lessons/258709)

## ⏱️ 문제 풀이 시간
- 총 소요 시간: **120분**

---

## 📊 문제 난이도
- [ ] 🟢 쉬움
- [x] 🟡 보통
- [ ] 🔴 어려움

---

## ⚙️ 사용한 알고리즘
- **조합(Combinations)**: n개 주사위 중 n/2개 선택
- **완전탐색(Brute Force)**: 모든 주사위 조합 시도
- **이진탐색(Binary Search)**: 승패 계산 최적화
- **시뮬레이션(Simulation)**: 데카르트 곱으로 모든 경우의 수 생성

---

## 💡 풀이 과정 (생각의 흐름)
### 1단계: 생각

![img](/images/pro258709.jpeg)

1. 주사위 나누는 경우의 수
    - 조합으로 한다면?
    - combinations(range(n), n//2)
    - n은 최대 10임. combinations(10, 5) = 252 => ok
2. A의 점수 분포
    - 주사위에 쓰인 수의 최대 갯수: 6개
    - 최대 주사위 수: 5개
    - 완탐으로 해도 6^5 = 7776번 => ok
    - B도 동일하게 완탐으로 구하기
3. 승률 구하기
    - 첫번째: 완탐
    ```python
    for a in a_sums:
        for b in b_sums:
            if a > b: win += 1
    ```
        - 시간복잡도: O(6^10) = 6천만 → 전체 시간 복잡도 252 × 6^10 = 약 150억
    - 두번째: 이진탐색
    ```python
    for a in a_sums:
        win += bisect.bisect_left(b_sums, a)
    ```
        - 시간복잡도: O(6^5 × log(6^5)) = 약 10만 → 전체 시간 복잡도 252 × 6^5 × log(6^5) = 약 2천5백만 -> 훨씬 효율적! ⭐

### 2단계: 구현

```python
from itertools import combinations, product
import bisect

def solution(dice):
    n = len(dice)
    max_win_rate = 0
    best_combination = []
    
    # A 인덱스
    for a_indices in combinations(range(n), n//2): # 최대 C(10, 5)
        # B 인덱스
        b_indices = [i for i in range(n) if i not in a_indices]
        
        # A의 점수 분포
        a_dice = [dice[i] for i in a_indices]
        a_sums = sorted([sum(rolls) for rolls in product(*a_dice)]) # 이진탐색 해야하므로 정렬
        
        # B의 점수 분포
        b_dice = [dice[i] for i in b_indices]
        b_sums = sorted([sum(rolls) for rolls in product(*b_dice)])
        
        # 승률 계산
        a_wins = 0
        for a in a_sums:
            a_wins += bisect.bisect_left(b_sums, a)

        win_rate = a_wins / (len(a_sums) * len(b_sums))
        
        if win_rate > max_win_rate:
            max_win_rate = win_rate
            best_combination = [i + 1 for i in a_indices]
        
    return best_combination
```

### 총 시간복잡도 계산
```
C(n, n/2) × [6^(n/2) + 6^(n/2) × log(6^(n/2))]
= 252 × [7,776 + 7,776 × 13]
≈ 252 × 100,000
≈ 2,500만 연산
```

## 💁🏻 회고
- 1-based 인덱스 실수
    - 처음에 0-based로 반환하는 실수함
- 이진탐색의 활용
    - 정렬된 데이터에서 "~보다 작은 개수" 찾기
    - bisect 라이브러리 활용하기
