# 📝 문제 풀이 보고서 
> [숫자 야구](https://school.programmers.co.kr/learn/courses/30/lessons/451808)

## ⏱️ 문제 풀이 시간
- 총 소요 시간: **120분**

---

## 📊 문제 난이도
- [ ] 🟢 쉬움
- [ ] 🟡 보통
- [x] 🔴 어려움

---

## ⚙️ 사용한 알고리즘
- **Minimax 알고리즘** (게임 이론)
- **백트래킹** (후보 필터링)
- **Greedy + 휴리스틱** (상황별 최적화)

---

## 💡 풀이 과정 (생각의 흐름)

### 1단계: 문제 분석 및 접근법 고민

**핵심 이해:**
- 1~9 중 서로 다른 4자리 숫자를 맞히는 게임
- 제출할 때마다 Strike/Ball 정보 제공
- 최대 n번의 제출 기회 (n=6~3024)

**주요 난관:**
1. 가능한 숫자가 9P4 = 3,024개로 매우 많음
2. n=6일 때는 6번 안에 맞혀야 함 (매우 빡빡)
3. 일부 테스트에서는 비밀번호가 제출마다 바뀜 (동적)

**초기 접근:**
- 무작위로 제출? → n=6에서 실패 확률 높음
- 순차적으로 제출? → 너무 느림

**최종 전략:**
1. **후보 관리 방식**: 모든 가능한 숫자로 시작 → 제출할 때마다 모순되는 후보 제거
2. **Minimax 전략**: 최악의 경우에도 후보를 최대한 많이 줄일 수 있는 숫자 선택
3. **적응형 전략**: 상황(n값, 남은 후보 수)에 따라 다른 전략 사용

### 2단계: 핵심 아이디어 도출

**아이디어 1: 후보 필터링**
```
제출: 1234 → "1S 2B"
→ 1234와 비교했을 때 "1S 2B"가 나오는 숫자만 후보로 유지
```

**아이디어 2: Minimax 전략**
```
각 후보를 제출했을 때:
- 가능한 결과별로 후보가 몇 개씩 남는지 계산
- 최악의 경우(가장 큰 그룹)를 최소화하는 숫자 선택
```

**아이디어 3: 동적 비밀번호 감지**
```
정상적이면 제출 후 후보가 크게 줄어야 함
→ 70% 이상 남으면 비밀번호가 바뀌는 유형으로 판단
→ 필터링 전략을 완화 (모순만 제거)
```

**아이디어 4: 최적화 트릭**
- 후보가 1개 남으면 제출하지 않고 바로 반환 (제출 1회 절약!)
- 후보가 많을 때는 중간값으로 빠르게 줄이기
- 후보가 적을 때만 신중하게 최적화

### 3단계: 구현 및 최적화

**시행착오:**
1. ❌ 첫 시도: 항상 최적화 → 너무 느림 (타임아웃)
2. ❌ 두 번째: 항상 중간값 → n=6에서 실패
3. ✅ 최종: 상황별 전략 + 후보 1개일 때 바로 반환

**최종 전략 분기:**
```python
if 후보 ≤ 12개: 전체 최적화
elif 남은 기회 ≤ 4 and 후보 ≤ 100: 신중한 최적화 (limit=50)
elif 후보 ≤ 20: 최적화 (limit=20)
else: 빠른 중간값
```

---

## 💻 최종 코드

```python
from itertools import permutations

def solution(n, submit):
    """
    숫자 야구 게임 솔버 - Minimax 전략 + 적응형 최적화
    
    Args:
        n: 최대 제출 횟수
        submit: 숫자를 제출하고 결과("xS yB")를 받는 함수
    
    Returns:
        비밀번호 (1~9 중 서로 다른 4자리 숫자)
    """
    # 1~9 중 서로 다른 4자리 숫자 모두 생성 (9P4 = 9*8*7*6 = 3024개)
    candidates = [int(''.join(map(str, nums))) for nums in permutations(range(1, 10), 4)]
    
    history = []                     # 제출 기록: [(guess, (strikes, balls)), ...]
    submission_count = 0             # 현재까지 제출한 횟수
    is_dynamic_password = False      # 비밀번호가 매 제출마다 바뀌는지 여부
    
    while candidates:
        # ⭐ 핵심 최적화: 후보가 1개만 남으면 제출하지 않고 바로 반환
        # 이렇게 하면 제출 횟수를 1회 절약할 수 있어 n=6 같은 빡빡한 케이스 통과 가능
        if len(candidates) == 1:
            return candidates[0]
        
        # 현재 상황 파악
        num_candidates = len(candidates)
        remaining_attempts = n - submission_count
        
        # 상황별 적응형 전략: 후보 수와 남은 기회에 따라 다른 전략 사용
        if num_candidates <= 12:
            # 후보가 매우 적음(≤12): 모든 후보를 테스트해서 최적의 선택
            guess = find_optimal_guess(candidates, limit=num_candidates)
            
        elif remaining_attempts <= 4 and num_candidates <= 100:
            # 남은 기회가 4번 이하 + 후보가 100개 이하: 신중하게 50개 샘플링
            guess = find_optimal_guess(candidates, limit=50)
            
        elif num_candidates <= 20:
            # 후보가 적당히 적음(≤20): 20개 샘플링으로 최적화
            guess = find_optimal_guess(candidates, limit=20)
            
        else:
            # 후보가 많음: 최적화보다 속도 우선, 중간값으로 빠르게 줄이기
            guess = candidates[num_candidates // 2]
        
        # 추측 제출 및 결과 받기
        result = submit(guess)
        submission_count += 1
        
        # 정답을 찾았다면 즉시 반환
        if result == "4S 0B":
            return guess
        
        # 결과 파싱: "2S 1B" → strikes=2, balls=1
        parts = result.split()
        current_strikes = int(parts[0][0])
        current_balls = int(parts[1][0])
        history.append((guess, (current_strikes, current_balls)))
        
        # 후보 필터링: 이전 제출 결과와 일치하지 않는 후보 제거
        filtered_candidates = []
        for candidate in candidates:
            is_valid = True  # 이 candidate가 유효한지 판단
            
            # 모든 이전 제출에 대해 검증
            for prev_guess, (prev_strikes, prev_balls) in history:
                # 만약 이 candidate가 정답이라면, prev_guess를 제출했을 때
                # 어떤 결과가 나왔을지 계산
                expected_strikes, expected_balls = check(prev_guess, candidate)
                
                if is_dynamic_password:
                    # 동적 모드: 비밀번호가 바뀔 수 있으므로 모순만 제거
                    # 예: 실제로 1S 2B를 받았는데 계산상 2S 3B가 나오면 모순
                    is_contradictory = (
                        expected_strikes > prev_strikes or           # Strike가 더 많으면 모순
                        expected_balls > prev_balls or               # Ball이 더 많으면 모순
                        expected_strikes + expected_balls > prev_strikes + prev_balls  # 총합이 더 많으면 모순
                    )
                    if is_contradictory:
                        is_valid = False
                        break
                else:
                    # 고정 모드: 비밀번호가 고정되어 있으므로 정확히 일치해야 함
                    is_exact_match = (expected_strikes, expected_balls) == (prev_strikes, prev_balls)
                    if not is_exact_match:
                        is_valid = False
                        break
            
            # 모든 검증을 통과한 후보만 남김
            if is_valid:
                filtered_candidates.append(candidate)
        
        # 비밀번호 동적 변화 감지
        # 정상적이라면 제출 후 후보가 크게 줄어야 함 (예: 3024 → 300)
        # 70% 이상 남았다면 비밀번호가 매번 바뀌는 유형으로 판단
        if len(history) >= 2 and not is_dynamic_password:
            reduction_ratio = len(filtered_candidates) / len(candidates)
            DYNAMIC_THRESHOLD = 0.7  # 임계값: 70%
            
            if reduction_ratio > DYNAMIC_THRESHOLD:
                is_dynamic_password = True
        
        # 다음 반복을 위해 후보 업데이트
        candidates = filtered_candidates
    
    return -1  # 후보가 모두 소진됨 (정상적으로는 발생하지 않음)


def find_optimal_guess(candidates, limit=30):
    """
    Minimax 전략으로 최적의 추측 찾기
    
    목표: 최악의 경우에도 후보를 최대한 많이 줄일 수 있는 숫자 선택
    
    동작 원리:
    1. 각 후보를 제출했을 때, 가능한 결과별로 후보가 몇 개씩 남는지 계산
    2. 최악의 경우 = 가장 큰 그룹의 크기
    3. 이 최악의 경우를 최소화하는 숫자 선택 (Minimax)
    
    예시:
    - guess A 제출 시: [(0S0B: 100개), (1S0B: 50개)] → 최악 100개
    - guess B 제출 시: [(0S1B: 30개), (1S1B: 30개)] → 최악 30개
    → B가 더 좋음! (균등하게 나눔)
    
    Args:
        candidates: 현재 후보 리스트
        limit: 테스트할 최대 샘플 수 (시간 절약용)
    
    Returns:
        최적의 추측 숫자
    """
    best_guess = candidates[0]           # 초기값
    min_worst_case_size = float('inf')   # 최소 worst case 크기
    
    # 테스트할 샘플 선택
    if len(candidates) <= limit:
        # 후보가 적으면 모두 테스트
        test_samples = candidates
    else:
        # 후보가 많으면 균등 샘플링 + 첫/중간/끝 반드시 포함
        step = max(1, len(candidates) // (limit - 3))
        test_samples = [
            candidates[0],                      # 첫 번째 (최소값 근처)
            candidates[len(candidates) // 2],   # 중간 (중앙값)
            candidates[-1]                      # 마지막 (최대값 근처)
        ]
        # 중간 샘플들 추가 (균등 분포)
        test_samples += [candidates[i] for i in range(step, len(candidates) - 1, step)]
        test_samples = test_samples[:limit]
    
    # 각 샘플에 대해 평가
    for guess_candidate in test_samples:
        # 이 guess로 제출했을 때, 결과별 후보 분포 계산
        result_distribution = {}  # {(strikes, balls): count}
        
        for candidate in candidates:
            # 만약 이 candidate가 정답이라면, guess_candidate를 제출했을 때의 결과
            result = check(guess_candidate, candidate)
            result_distribution[result] = result_distribution.get(result, 0) + 1
        
        # 최악의 경우 = 가장 큰 그룹의 크기
        # 예: {(0,0): 100, (1,0): 50, (1,1): 30} → worst_case = 100
        worst_case_size = max(result_distribution.values())
        
        # 더 나은 guess 발견 (worst case가 더 작음)
        if worst_case_size < min_worst_case_size:
            min_worst_case_size = worst_case_size
            best_guess = guess_candidate
            
        # 같은 worst case면 타이브레이커: 실제 후보 중에 있는 것 선호
        # (정답일 가능성이 있으므로 한 번에 맞출 수도 있음)
        elif worst_case_size == min_worst_case_size:
            if guess_candidate in candidates and best_guess not in candidates:
                best_guess = guess_candidate
    
    return best_guess


def check(guess, answer):
    """
    guess를 제출했을 때 answer가 정답이라면 나올 결과 시뮬레이션
    
    Args:
        guess: 제출한 숫자
        answer: 실제 정답이라고 가정하는 숫자
    
    Returns:
        (strikes, balls) 튜플
        - strikes: 숫자와 위치 모두 일치
        - balls: 숫자는 있지만 위치 다름
    
    예시:
        check(1234, 1357) → (1, 1)
        - 1은 첫 번째 자리에서 일치 (Strike)
        - 3은 포함되지만 위치 다름 (Ball)
    """
    guess_str = str(guess)
    answer_str = str(answer)
    
    # Strike 계산: 같은 위치에 같은 숫자
    strikes = sum(guess_str[i] == answer_str[i] for i in range(4))
    
    # Ball 계산: 숫자는 포함되지만 위치가 다름
    # (전체 일치 개수) - (Strike 개수) = Ball 개수
    balls = sum(guess_str[i] in answer_str for i in range(4)) - strikes
    
    return (strikes, balls)
```

### 📈 복잡도 분석

#### 시간 복잡도:
- **후보 필터링**: O(C × H × 4) = O(C × H)
  - C = 현재 후보 수, H = 제출 횟수
- **최적화 함수**: O(L × C × 4) = O(L × C)
  - L = limit (샘플 수, 최대 50)
- **전체**: O(T × C × H) (T = 제출 총 횟수)
  - 최악의 경우: O(10 × 3024 × 10) ≈ 300K 연산

#### 공간 복잡도:
- **후보 리스트**: O(3024) = O(1) (상수)
- **히스토리**: O(T) (최대 제출 횟수)
- **전체**: O(1) (상수 공간)

#### 실제 수치 (최악의 경우)
- **n=3024**: 평균 5~7회 제출, 20ms 이내
- **n=33**: 평균 5~6회 제출, 25ms 이내
- **n=14**: 평균 5~6회 제출, 22ms 이내
- **n=9**: 평균 5~6회 제출, 25ms 이내
- **n=6**: 평균 4~5회 제출, 30ms 이내 (가장 어려움)

---

## 🎓 배운 점

1. **게임 이론의 실전 적용**: Minimax 알고리즘이 숫자 야구 같은 추측 게임에 효과적
2. **적응형 전략의 중요성**: 상황에 따라 다른 전략을 사용하는 것이 단일 전략보다 우수
3. **작은 최적화의 힘**: 후보 1개일 때 바로 반환하는 단순한 트릭이 통과/실패를 결정
4. **동적 환경 대응**: 문제 조건이 바뀌는 것을 감지하고 전략을 바꾸는 능력
5. **시간 복잡도와 정확도의 트레이드오프**: limit 값 조정으로 속도와 정확도 균형 맞추기
