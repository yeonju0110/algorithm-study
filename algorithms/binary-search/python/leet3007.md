# 📝 문제 풀이 보고서 
> [Maximum Number That Sum of the Prices Is Less Than or Equal to K](https://leetcode.com/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/)

## ⏱️ 문제 풀이 시간
- 총 소요 시간: **180분**

---

## 📊 문제 난이도
- [ ] 🟢 쉬움
- [ ] 🟡 보통
- [x] 🔴 어려움

---

## ⚙️ 사용한 알고리즘
- 이진 탐색

---

## 💡 풀이 과정 (생각의 흐름)
### 1단계
- 우선 시간복잡도를 줄이는 게 관건이니, logN으로 풀어야겠다..
- 근데 어캐 완전탐색을 안할 수 있지?!!!

<img src="/images/leet3007.jpeg" width="500px" />


```python
class Solution:
    def findMaximumNumber(self, k: int, x: int) -> int:
        start = 0
        end = 10**15  # 충분히 큰 값
        
        while start < end:
            mid = (start + end + 1) // 2  # +1로 upper bound 찾기
            
            acc_price = self.calculateAccumulatedPrice(mid, x)
            
            if acc_price <= k:
                start = mid  # 가능하면 더 큰 수 시도
            else:
                end = mid - 1  # 불가능하면 더 작은 수
        
        return start
    
    def calculateAccumulatedPrice(self, num, x):
        total = 0
        pos = x
        max_pos = num.bit_length()

        while pos <= max_pos:
            total += self.countBitsAtPosition(num, pos)
            pos += x
        return total

    # 1부터 num까지 pos번째 비트가 1인 개수
    def countBitsAtPosition(self, num, pos):
        # 이 함수가 관건...
        return total
```

### 2단계: countBitsAtPosition 함수 작성하기
> 예시 1: num=14, pos=2

- 질문: 0부터 14까지 숫자 중에서 2번째 비트가 1인 개수는?
- Step 1: 이진수로 나열
    ```
    번호   이진수    2번째 비트
    0     0000         0
    1     0001         0
    2     0010         1  ✓
    3     0011         1  ✓
    4     0100         0
    5     0101         0
    6     0110         1  ✓
    7     0111         1  ✓
    8     1000         0
    9     1001         0
    10     1010         1  ✓
    11     1011         1  ✓
    12     1100         0
    13     1101         0
    14     1110         1  ✓
    ```
    - 정답: 7개 (2, 3, 6, 7, 10, 11, 14)

- Step 2: 패턴 발견
    - 2번째 비트만 추출하면:
        ```
        0 0 1 1 | 0 0 1 1 | 0 0 1 1 | 0 0 1
        └──────┘  └──────┘  └──────┘  └────
          주기1     주기2     주기3    남은부분
        ```
    - 패턴: [0, 0, 1, 1] 반복!

- Step 3: 코드로 계산
    ```python
    num = 14
    pos = 2

    # 1. 주기 계산
    cycle = 2 ** 2 = 4
    ones_per_cycle = 2 ** (2-1) = 2

    # 패턴 [0, 0, 1, 1] → 4개 주기, 그 중 2개가 1


    # 2. 완전한 주기 개수
    complete_cycles = (14 + 1) // 4 = 15 // 4 = 3

    # 0~14는 15개 숫자
    # 4개씩 묶으면 3묶음 완성


    # 3. 완전한 주기의 1 개수
    total = 3 * 2 = 6

    # 주기1: [0,0,1,1] → 2개
    # 주기2: [0,0,1,1] → 2개  
    # 주기3: [0,0,1,1] → 2개
    # 합계: 6개


    # 4. 남은 부분
    remainder = (14 + 1) % 4 = 15 % 4 = 3

    # 15개를 4개씩 묶고 남은 개수
    # [0,0,1,1] [0,0,1,1] [0,0,1,1] [0,0,1]
    #                                 └─3개


    # 5. 남은 부분의 1 개수
    max(0, 3 - 2) = max(0, 1) = 1

    # 남은 3개: [0, 0, 1]
    #            ↑  ↑  ↑
    #          앞2개  뒤1개
    #          (0)   (1)

    # 6. 최종 답
    total = 6 + 1 = 7 ✓
    ```

- 정리하자면
    ```python
    # 주어진 값
    num = ??        # 마지막 숫자
    pos = ??        # 확인할 비트 위치

    # 계산
    cycle = 2 ** pos                    # 패턴의 주기 길이
    ones_per_cycle = 2 ** (pos - 1)     # 한 주기에 1의 개수

    complete_cycles = (num + 1) // cycle    # 완전한 주기 개수
    remainder = (num + 1) % cycle           # 남은 숫자 개수

    # 답
    total = complete_cycles * ones_per_cycle           # 완전한 주기들
    total += max(0, remainder - ones_per_cycle)        # 남은 부분
    ```
    - 패턴은 항상 반복
        - pos=1: [0,1] 반복
        - pos=2: [0,0,1,1] 반복
        - pos=3: [0,0,0,0,1,1,1,1] 반복
    - 패턴의 앞쪽 절반은 0, 뒤쪽 절반은 1:
        - ones_per_cycle = cycle // 2
    - 남은 부분에서 1의 개수:
        - remainder - ones_per_cycle (단, 음수면 0)
        - 왜냐면 앞의 ones_per_cycle개는 0이고, 나머지가 1이니까! ⭐️

- 이제 완성을 해보자
    ```python
    class Solution:
        def findMaximumNumber(self, k: int, x: int) -> int:
            # 생략
            return start
        
        def calculateAccumulatedPrice(self, num, x):
            # 생략
            return total

        # 1부터 num까지 pos번째 비트가 1인 개수 -> 이 함수 완성! O(1)으로 계산 가능
        def countBitsAtPosition(self, num, pos):
            # num+1개의 숫자 (0부터 num까지)
            cycle = 2 ** pos  # 주기
            ones_per_cycle = 2 ** (pos - 1)  # 한 주기당 1의 개수
            
            complete_cycles = (num + 1) // cycle
            remainder = (num + 1) % cycle
            
            # 완전한 주기들의 1의 개수
            total = complete_cycles * ones_per_cycle
            
            # 남은 부분의 1의 개수는?
            total += max(0, remainder - ones_per_cycle)
            
            return total
    ```

- 총 시간 복잡도
    ```
    이진 탐색 × calculateAccumulatedPrice × countBitsAtPosition
    = O(50) × O(60) × O(1)
    = O(3000)
    = O(1) (상수로 취급 가능!)
    ```


## 😢 회고
### 이런 문제 유형을 어떻게 알아볼까?
- Step 1: 제목/첫 문장 확인
    ```python
    python"Maximum Number That [조건]"
    # → 최댓값 찾기 문제구나!
    # → 이진 탐색 가능성 80%
    ```
- Step 2: 제약 조건 확인
    ```python
    python"1 ≤ k ≤ 10¹⁵"
    # → 범위가 매우 넓네
    # → O(n) 불가능, 이진 탐색 필요!
    # → 이진 탐색 가능성 90%
    ```
- Step 3: 조건의 단조성 확인
    ```python
    "accumulated price of num is ... less than or equal to k"
    # → num이 커지면 price도 커지나?
    # → YES! 단조성 있음
    # → 이진 탐색 확정! 100%
    ```
- Step 4: 검증 함수 구상
    ```python
    def canAchieve(num, k):
    # num일 때 조건을 만족하나?
    # 이게 계산 가능하면 이진 탐색 OK!
    ```

    