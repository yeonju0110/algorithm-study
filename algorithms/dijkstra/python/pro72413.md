# 📝 문제 풀이 보고서 
> [합승 택시 요금](https://school.programmers.co.kr/learn/courses/30/lessons/72413)

## ⏱️ 문제 풀이 시간
- 총 소요 시간: **50분**

---

## 📊 문제 난이도
- [ ] 🟢 쉬움
- [x] 🟡 보통
- [ ] 🔴 어려움

---

## ⚙️ 사용한 알고리즘
- 다익스트라 알고리즘

---

## 💡 풀이 과정 (생각의 흐름)

### 1단계: 문제 분석 및 알고리즘 선택
- 최단 경로 알고리즘을 비교해봐야지

**알고리즘 선택: 다익스트라 vs 플로이드 워셜?**
| 알고리즘 | 시간복잡도 | n=200일 때 |
|---------|-----------|-----------|
| 다익스트라 × 3번 | O(3 × E log V) | ≈ 3 × 20,000 × log(200) ≈ 450,000 |
| 플로이드-워셜 | O(V³) | 200³ = 8,000,000 |

**결론:** n=200이고 간선 수가 최대 20,000개일 때, 다익스트라가 약 **18배 더 효율적**

**계산 근거:**
- 다익스트라는 간선 수(E)에 의존: E가 V²보다 훨씬 적을 때 유리
- 플로이드-워셜은 노드 수(V)의 세제곱: 노드가 많아질수록 급격히 느려짐
- **V³ vs 3E log V 비교**: 8,000,000 vs 450,000
- **손익분기점**: V³ = 3E log V를 만족하는 지점. 대략 V가 작고(V<100) 그래프가 밀집(E ≈ V²)일 때만 플로이드-워셜이 유리


### 2단계: 다익스트라 함수 구현
1. 시작 노드에서 각 노드까지의 최단 거리를 구함
2. 우선순위 큐를 사용해 항상 최소 거리 노드부터 처리
3. 방문한 노드를 거쳐 다른 노드로 가는 경로가 더 짧으면 갱신

```python
def dijkstra(graph, start, n):
    distance = [float('inf')] * (n + 1)
    distance[start] = 0
    heap = [(0, start)] # (거리, 노드)
    
    while heap:
        # 1. 힙에서 최소 거리 노드 꺼내기
        dist, now = heapq.heappop(heap)
        
        # 2. 이미 처리된 노드면 스킵
        if distance[now] < dist:
            continue
        
        # 3. 인접 노드들 확인하며 거리 갱신
        for node, cost in graph[now]:
            new_cost = dist + cost
            
            # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
            if new_cost < distance[node]:
                distance[node] = new_cost
                heapq.heappush(heap, (new_cost, node))
    
    return distance
```

### 3단계: 핵심 아이디어 - 모든 헤어지는 지점 탐색
- **왜 이 방법을 사용했는가?**
    - 합승 종료 지점 X를 모르는 상황에서, X는 1~n 중 **어떤 노드든 될 수 있음**
```
케이스 1: X = S (처음부터 안 탐)
총 비용 = 0 + (S→A) + (S→B)

케이스 2: X = 중간 지점
총 비용 = (S→X) + (X→A) + (X→B)

케이스 3: X = A (A까지 합승 후 B만 이동)
총 비용 = (S→A) + 0 + (A→B)
```

**왜 3번의 다익스트라가 필요한가?**

각 지점 X에서의 비용 계산에 필요한 정보:
1. `dist_S[X]`: S에서 X까지의 최단 거리 → **S에서 출발하는 다익스트라**
2. `dist_A[X]`: X에서 A까지의 최단 거리 → **A에서 출발하는 다익스트라** (무방향 그래프이므로 A→X = X→A)
3. `dist_B[X]`: X에서 B까지의 최단 거리 → **B에서 출발하는 다익스트라** (무방향 그래프이므로 B→X = X→B)

**최종 로직:**
```python
# 모든 지점을 합승 종료 지점으로 시도
for X in range(1, n + 1):
    total_cost = dist_S[X] + dist_A[X] + dist_B[X]
    answer = min(answer, total_cost)
```

### 완성코드

```python
import heapq
from collections import defaultdict

def dijkstra(graph, start, n):
    distance = [float('inf')] * (n + 1)
    distance[start] = 0
    heap = [(0, start)] # (거리, 노드)
    
    while heap:
        # 1. 힙에서 최소 거리 노드 꺼내기
        dist, now = heapq.heappop(heap)
        
        # 2. 이미 처리된 노드면 스킵
        if distance[now] < dist:
            continue
        
        # 3. 인접 노드들 확인하며 거리 갱신
        for node, cost in graph[now]:
            new_cost = dist + cost
            
            # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
            if new_cost < distance[node]:
                distance[node] = new_cost
                heapq.heappush(heap, (new_cost, node))
    
    return distance

def solution(n, s, a, b, fares):
    # 그래프 초기화
    graph = defaultdict(list)
    
    # 양방향 그래프 구성
    for c, d, f in fares:
        graph[c].append((d, f))
        graph[d].append((c, f))
    
    # 3번 다익스트라
    dist_S = dijkstra(graph, s, n)
    dist_A = dijkstra(graph, a, n)
    dist_B = dijkstra(graph, b, n)
    
    # 모든 합승 종료 지점 X 시도
    answer = float('inf')
    for X in range(1, n + 1):
        total_cost = dist_S[X] + dist_A[X] + dist_B[X]
        answer = min(answer, total_cost)
                                   
    return answer
```

### 📈 복잡도 분석
#### 시간 복잡도
- **그래프 구성**: O(E) = O(fares 배열 길이)
- **다익스트라 1회**: O(E log V)
  - 모든 간선을 최대 1번씩 확인: O(E)
  - 각 간선마다 힙 연산(push/pop): O(log V)
- **다익스트라 3회**: O(3 × E log V) = **O(E log V)**
- **합승 지점 탐색**: O(n) = O(V)
- **총 시간복잡도**: **O(E log V)** ✅

#### 공간 복잡도
- **그래프**: O(E) - 간선 정보 저장
- **거리 배열**: O(3V) - dist_S, dist_A, dist_B
- **힙**: O(V) - 최악의 경우 모든 노드
- **총 공간복잡도**: **O(E + V)**

#### 실제 수치 (최악의 경우)
- V = 200, E = 200 × 199 / 2 = 19,900
- 3 × 19,900 × log(200) ≈ 3 × 19,900 × 7.6 ≈ **454,000 연산**
- 효율성 테스트 충분히 통과 ✅

---

## 😢 회고
- 무방향 그래프의 특성을 활용해 "역방향 거리 = 정방향 거리" 이용하기
- `graph = []` 초기화 후 인덱스 접근 시 에러 발생 → defaultdict 또는 미리 초기화 필요