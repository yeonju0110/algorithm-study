# 📝 문제 풀이 보고서 
> [n + 1 카드게임](https://school.programmers.co.kr/learn/courses/30/lessons/258707)

## ⏱️ 문제 풀이 시간
- 총 소요 시간: **60분**

---

## 📊 문제 난이도
- [ ] 🟢 쉬움
- [x] 🟡 보통
- [ ] 🔴 어려움

---

## ⚙️ 사용한 알고리즘
- 시뮬레이션 (게임 규칙 구현)
- 그리디 (우선순위 기반 선택)
- 해시 / 집합 (빠른 탐색)

---

## 💡 풀이 과정 (생각의 흐름)
### 1단계: 문제 이해

- 초기에 n/3장의 카드를 받고, 매 라운드마다 2장씩 뽑음
- 합이 n+1인 카드 쌍을 내야 다음 라운드 진행
- 뽑은 카드를 사려면 1코인씩 필요
- 최대한 많은 라운드를 진행하는 것이 목표

### 2단계: 첫 번째 시도 (실패)
```python
# 문제점: 카드를 뽑자마자 바로 사용 여부를 결정
# → 유연성 부족, 동전 낭비
for i in range(first_card_len, len(cards), 2):
    a, b = cards[i], cards[i + 1]
    
    # 뽑은 카드끼리
    if coin >= 2 and (a + b) == (n + 1):
        coin -= 2
        continue
    
    # 가지고 있는거 + 뽑은 거 
    if coin >= 1 and (n + 1 - a) in user_cards:
        coin -= 1
        user_cards.append(a)
```
- 문제점:
    - 우선순위가 잘못됨 (비싼 것부터 시도)
    - 뽑은 카드를 즉시 구매 결정 → 나중을 위한 여지 없음

### 3단계: 우선순위 수정
- 0코인 (손패끼리) → 1코인 → 2코인 순서로 변경
- 각 우선순위에서 성공하면 즉시 다음 라운드로
- 여전히 남은 문제:
    - 뽑은 카드를 어떻게 관리할지 불명확
    - "미리 사두기" 전략이 오히려 비효율적

### 4단계: 핵심 통찰 - Lazy Evaluation
- 발상의 전환:
    - 뽑은 카드를 바로 사지 말고 drawn 집합에 보관
    - 필요할 때만 코인을 써서 사용
    - 늦게 결정할수록 더 많은 정보를 가지고 판단 가능

- 자료구조 변경:
    ```python
    hand = set()   # 사용 가능한 카드 (이미 산 카드)
    drawn = set()  # 뽑았지만 아직 사지 않은 카드
    ```

### 5단계: 최종 구현
```python
def solution(coin, cards):
    n = len(cards)
    target = n + 1
    
    # 초기 손패
    hand = set(cards[:n//3])
    # 뽑은 카드들 (아직 사지 않음)
    drawn = set()
    
    round_num = 1
    
    # 매 라운드마다 카드 2장씩 뽑음
    for i in range(n//3, n, 2):
        # 카드 2장을 drawn에 추가
        drawn.add(cards[i])
        drawn.add(cards[i+1])
        
        found = False
        
        # 1순위: hand끼리 (0코인)
        for card in list(hand):  # list()로 복사하여 순회 중 수정 가능
            complement = target - card
            if complement in hand and card < complement:  # card < complement로 중복 방지
                hand.discard(card)
                hand.discard(complement)
                round_num += 1
                found = True
                break
        
        if found:
            continue
        
        # 2순위: hand + drawn (1코인)
        if coin >= 1:
            for card in list(hand):
                complement = target - card
                if complement in drawn:
                    hand.discard(card)
                    drawn.discard(complement)
                    coin -= 1
                    round_num += 1
                    found = True
                    break
        
        if found:
            continue
        
        # 3순위: drawn끼리 (2코인)
        if coin >= 2:
            for card in list(drawn):
                complement = target - card
                if complement in drawn and card < complement:
                    drawn.discard(card)
                    drawn.discard(complement)
                    coin -= 2
                    round_num += 1
                    found = True
                    break
        
        if found:
            continue
        
        # 쌍을 만들 수 없으면 종료
        break
    
    return round_num
```
1. deque 대신 set 사용 → O(1) 탐색/삭제
2. 뽑은 카드를 drawn에 모아두고 필요할 때만 사용
3. 우선순위: 0코인 → 1코인 → 2코인 (그리디)

## 💁🏻 회고
- 그리디가 최적해를 보장하는지 판단
    - 처음엔 "미리 사두는" 전략이 더 좋을 것 같았음
    - Lazy Evaluation이 더 효율적임을 깨달음
    - 즉시 결정 vs 지연 결정: 불확실한 상황에서는 지연 결정이 유리할 수 있음

- 상태 관리의 복잡성
    - hand와 drawn을 분리해서 관리하는 아이디어 도출이 어려웠음

- 그리디 알고리즘의 우선순위 설정이 핵심 (코인 최소 사용)