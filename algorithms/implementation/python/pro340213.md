# 📝 문제 풀이 보고서 
> [동영상 재생기](https://school.programmers.co.kr/learn/courses/30/lessons/340213)

## ⏱️ 문제 풀이 시간
- 총 소요 시간: **30분**

---

## 📊 문제 난이도
- [x] 🟢 쉬움
- [ ] 🟡 보통
- [ ] 🔴 어려움

---

## ⚙️ 사용한 알고리즘
- 구현 (Implementation)
- 시뮬레이션 (Simulation)
- 시간 형식 변환 (문자열 파싱)

---

## 💡 풀이 과정 (생각의 흐름)

### 1단계
1. "mm:ss" 형식을 초 단위로 변환하여 계산 → 다시 "mm:ss"로 복원
    - 초 단위 계산이 훨씬 간단
2. prev/next 명령으로 10초 단위 이동
3. 경계값 처리 (0초 미만 → 0초, 영상 길이 초과 → 마지막)
4. 오프닝 구간에 있으면 자동으로 오프닝 끝으로 이동
    - 초기에 오프닝 구간인지 검사
    - 명령 후 오프닝 체크 필요

```python
def solution(video_len, pos, op_start, op_end, commands):
    def convert_to_seconds(t):
        mm, ss = t.split(':')
        return int(mm) * 60 + int(ss)

    def convert_to_time(s):
        mm = s // 60
        ss = s % 60
        return f"{mm:02d}:{ss:02d}"
    
    def opening_jump(op_s, op_e, now):
        if op_s <= now <= op_e:
            return op_e
        return now
        
    def move_next(now, end):
        return min(now + 10, end)
    
    def move_prev(start, now):
        return max(start, now - 10)
    
    # 초 단위로 변환
    video_len_sec = convert_to_seconds(video_len)
    pos_sec = convert_to_seconds(pos)
    op_start_sec = convert_to_seconds(op_start)
    op_end_sec = convert_to_seconds(op_end)
    
    # 시작 위치 오프닝 체크
    pos_sec = opening_jump(op_start_sec, op_end_sec, pos_sec)
    
    # 명령 처리
    for cmd in commands:
        if cmd == 'next':
            pos_sec = move_next(pos_sec, video_len_sec)
        elif cmd == "prev":
            pos_sec = move_prev(0, pos_sec)
        
        # 명령 후 오프닝 체크
        pos_sec = opening_jump(op_start_sec, op_end_sec, pos_sec)
        
    return convert_to_time(pos_sec)
```

### 📈 복잡도 분석
- 시간 복잡도: O(n)
    - n = commands의 길이 (최대 100)
    - 각 명령당 O(1) 연산 수행
    - 문자열 변환: O(1) (고정 길이 "mm:ss")
- 공간 복잡도: O(1)
    - 입력 크기와 무관하게 고정된 변수만 사용
    - 추가 자료구조 없음

---

## 😢 회고
- f"{mm:02d}:{ss:02d}": 포매팅으로 0 패딩 처리
- mm, ss = divmod(s, 60)  # 더 효율적이고 파이썬스러움

