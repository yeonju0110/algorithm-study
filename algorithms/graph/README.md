# 📑 그래프 이론

## 서로소 집합 자료구조

- 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
- 서로소: 공통 원소가 없는 두 집합
- 두 종류의 연산 지원
  1. 합집합(Union): 두 개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
  2. 찾기(Find): 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산
- 서로소 집합 자료구조는 합치기 찾기(Union Find)라고 불림

<br />

- 여러 개의 합치기 연산이 주어졌을 때 서로소 집합 자료구조의 동작 과정

  1. 합집합(Union) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인
     1. A와 B의 루트 노드 A', B'를 각각 찾음
     2. A'를 B'의 부모 노드로 설정
  2. 모든 합집합(Union) 연산을 처리할 때까지 1번의 과정을 반복함

- 초기 단계
  - 노드의 개수 크기의 부모 테이블을 초기화함

<br />

### [기본적인 구현 방법](/python/이코테/graph/1.py)

- 문제점
  - 합집합(Union) 연산이 편향되게 이루어지는 경우 찾기(Find) 함수가 비효율적으로 동작함
  - 최악의 경우에는 찾기(Find)함수가 모든 노드를 다 확인하게 되어 시간 복잡도가 `O(V)`

### [경로 압축](/python/이코테/graph/2.py)

- 찾기(Find) 함수를 최적화하기 위한 방법으로 경로 압축 이용
- 찾기(Find) 함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 바로 갱신
- 문제
  - [팀 결성](/python/이코테/graph/6.py)
  - [도시 분할 계획](/python/이코테/graph/7.py)

<br />

### [서로소 집합을 이용한 사이클 판별](/python/이코테/graph/3.py)

- 서로소 집합: 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있음
  - 방향 그래프에서 사이클 여부는 DFS를 이용하여 판별
- 사이클 판별 알고리즘
  1. 각 간선을 하나씩 확인 -> 두 노드의 루트 노드 확인 (Find)
     1. 루트 노드가 서로 다르다면 -> 두 노드에 대해 합집합(Union) 연산 수행
     2. 로트 노드가 서로 같다면 -> 사이클(Cycle)이 발생한 것
  2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정 반복

## 신장트리

- 그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프
  - 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다 = 트리의 조건

### 최소 신장 트리

- ex. N개의 도시, 두 도시 사이에 도로를 놓아 전체 도시가 서로 연결될 수 있게 도로를 설치하는 경우

#### [크루스칼 알고리즘](/python/이코테/graph/4.py)

- 대표적인 최소 신장 트리 알고리즘
- 그리디 알고리즘으로 분류
- 동작 과정
  1. 간선 데이터를 비용에 따라 오름차순으로 정렬
  2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인함
     1. 사이클이 발생하지 않는 경우 -> 최소 신장 트리에 포함시킴
     2. 사이클이 발생하는 경우 -> 최소 신장 트리에 포함시키지 X
  3. 모든 간선에 대하여 2번의 과정을 반복함
- 성능: 간선 개수 E -> `O(ElogE)`
  - 가장 많은 시간을 요구하는 곳 = 간선 정렬
    - 표준 라이브러리를 이용해 E개의 데이터를 정렬하기 위한 시간 복잡도: `O(ElogE)`

---

## [위상 정렬](/python/이코테/graph/5.py)

- `사이클이 없는 방향 그래프(DAG)`의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것
  - DAG (Direct Acyclic Graph): 순환하지 않는 방향 그래프
- 여러 가지 답이 존재할 수 있음
  - 한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우
- 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단할 수 있음
  - 사이클에 포함된 원소 중에서 어떠한 원소도 큐에 들어가지 못함
- 스택을 활용한 DFS를 이용해 위상 정렬을 수행할 수도 있음
- 성능
  - 차례대로 모든 노드 확인 -> 각 노드에서 나가는 간선을 차례대로 제거
  - `O(V + E)`
- Ex. 선수과목을 고려한 학습 순서 설정

<br />

- 진입차수: 특정한 노드로 들어오는 간선의 개수
- 진출차수: 특정한 노드에서 나가는 간선의 개수

<br />

- 풀이방법: 큐, DFS
- 큐
  1. 진입차수가 0인 모든 노드를 큐에 넣음
  2. 큐가 빌 때까지 다음의 과정을 반복함
     1. 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거
     2. 새롭게 진입차수가 0이 된 노드를 큐에 넣음
  3. 결과적으로 각 노드가 큐에 들어온 순서가 위상 정렬을 수행한 결과

---

## 트리

- 그래프의 한 형태
- 순환이 없는 연결 그래프

### 용어

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/f73d62c3-6dbc-494d-bfe5-8fd0512b6b6d)

#### 주요 용어

1. `노드 (Node)`

   - 트리를 구성하는 기본 요소
   - 값과 하위 노드를 가리키는 포인터를 가짐

2. `간선 (Edge)`: 노드와 노드를 연결한 선 (link)
3. `루트`: 부모 노드가 없는 최상위 노드. 모든 트리의 루트는 하나다.
4. `부모(parent) 노드`: 자식(child) 노드를 가진 노드
5. `자식(child) 노드`: 부모 노드의 하위 노드
6. `형제(siblings) 노드`: 부모가 같은 노드
7. `리프(leaf) 노드`: 자식이 없는 노드
8. `서브 트리(sub tree)`: 특정 노드를 루트로 생각할 때 생기는 트리

#### 기타 용어

1. `크기(size)`: 자신을 포함한 모든 자식 노드의 개수
2. `레벨(level)`: 루트 노드부터 특정 노드까지 연결된 간선의 수
3. `깊이(depth)`: 루트 노드부터 특정 노드까지의 거리, 수치로만 보면 레벨과 같은 것 같다.
4. `높이(height)`: 노드에서 가장 깊은 노드까지의 길이
5. `경로(path)`: 한 노드에서 다른 노드로 갈 때 거쳐 가는 노드들의 순서
6. `차수(degree)`: 자식의 개수

### 이진 트리 (binary tree)

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/c9eba5ad-a991-4bcb-9d17-267c2dfe7f9c)

- 모든 노드가 두 개 이하의 자식 노드를 가지는 트리

### 순회 (traversal)

- 트리에서 각 노드를 한 번씩 체계적으로 방문하는 과정

#### 부모, 왼쪽, 오른쪽 노드 순서에 따라

- 방법: 전위 순회, 중위 순회, 후위 순회
- 구현: 재귀 or 스택

#### 레벨 순서에 따라

- 방법: 레벨 순서 순회
- 구현: 큐

#### 1. 전위 순회 (Pre-order)

> 루트 -> 왼쪽 자식 -> 오른족 자식

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/9eff9393-a95d-4888-a9cf-71ceba055a4b)

- 결과: A -> B -> D -> G -> E -> C -> F

#### 2. 중위 순회 (In-order)

> 왼쪽 자식 -> 루트 -> 오른쪽 노자식드

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/74aa0994-9851-446a-bb91-1efca252e4db)

- 결과: G -> D -> B -> E -> A -> F -> C

#### 3. 후위 순회 (Post-order)

> 왼쪽 자식 -> 오른쪽 자식 -> 루트

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/b67dd858-32b1-44e7-ae84-df64cf0edbdc)

- 결과: G -> D -> E -> B -> F -> C -> A

#### 4. 레벨 순서 순회 (Level-order)

> 레벨 0부터 차례로 방문, 같은 레벨은 왼 -> 오

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/0da75986-7504-4526-93b5-7bf12ba5c510)

- 결과: A -> B -> C -> D -> E -> F -> G

### 완전 이진 트리

#### Reference

- [wiki docs](https://wikidocs.net/193702)
