# 🌳 트리와 그래프

## ❄️ 트리의 특징

- 노드로 이루어진 자료구조
- 하나의 루트 노드를 가짐
- 루트 노드는 0개 이상의 자식 노드를 갖고 있음
- 그 자식 노드 또한 0개 이상의 자식 노드를 갖고 있고, 이는 반복적으로 정의된다.
- 사이클(cycle)이 존재할 수 없음
- 노드들은 특정 순서로 나열될 수도 있고 그럴 수 없을 수도 있음
- 각 노드는 어떤 자료형으로도 표현 가능함
- 각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수도 있음

> 💡 트리 및 그래프 문제들은 대부분 세부사항이 모호하거나 가정 자체가 틀린 경우가 많음. 따라서 아래의 이슈들에 대해 유의하고, 필요하면 명확하게 해 줄 것을 요구하자!

</aside>

## ❄️ 트리의 종류

### 📍 이진 트리 (binary tree)

- 이진 트리(binary tree)는 각 노드가 최대 두 개의 자식을 갖는 트리
- 모든 트리가 이진 트리는 아님
- 종종 이진 트리가 아닌 트리를 다뤄야 할 때가 있음
  - 예를 들어, 전화번호를 표현할 때 트리를 사용한다고 가정해 보자.
  - 이때는 각 노드가 10개의 자식을 갖는 10차 트리를 사용해야 할 것
  - 자식이 없는 노드는 ‘말단’노드라고 부름

### 📍 이진 탐색 트리

- ‘모든 왼쪽 자식들 ≤ n < 모든 오른쪽 자식들’ 인 이진 트리

> 💡 - **같은 값을 처리하는 방식**에 따라 정의가 달라질 수 있음 → 면접관이랑 미리 명확히하기
> 방식 1. 트리는 중복된 값을 가지면 안된다.
> 방식 2. 중복된 값은 오른쪽 혹은 양쪽 어느 곳이든 존재할 수 있다.

### 📍 균형 vs 비균형

- 많은 트리가 균형 잡혀 있긴 하지만 전부 그런 것은 아님
- 균형을 잡는다는 것이 왼쪽과 오른쪽 부분 트리의 크기가 완전히 같게 하는 것을 의미하지는 않음
- ‘균형’ 트리인지 아닌지 확인하는 방법 중 하나는 ‘너무 불균형한건 아닌지’ 확인하는 것 이상의 의미를 가짐
- O(logN) 시간에 insert와 find를 할 수 있을 정도로 균형이 잘 잡혀 있지만, 그렇다고 꼭 완벽하게 균형 잡혀 있을 필요는 없음
- 균형 트리의 일반적인 유형: 레드 블랙 트리, AVL 트리

### 📍 완전 이진 트리 (complete binary tree)

- 트리의 모든 높이에서 노드가 꽉 차 있는 이진 트리를 말함
- 마지막 단계(level)는 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워져야 함
  ![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/e6f11999-ffd1-4d64-a130-3331b24e31cd)

마지막 단계(level)는 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워져야 함

### 📍 전 이진 트리 (full binary tree)

- 모든 노드의 자식이 없거나 정확히 두 개 있는 경우를 말함
- 즉, 자식이 하나만 있는 노드가 존재해서는 안됨

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/112630f6-34bf-4078-b152-b9c49ed67d92)

### 📍 포화 이진 트리 (perfect binary tree)

- **전 이진 트리**이면서 **완전 이진 트리**인 경우를 말함
- 모든 노드의 자식이 정확히 두 개 + 트리의 모든 높이에서 노드가 꽉 차 있는 경우
  - 모든 말단 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수가 최대가 되어야 함
  - 노드의 개수가 정확히 $2^{k} -1$ (k는 트리의 높이)개여야 함

![alt text](image.png)

## ❄️ 이진 트리 순회

### 📍 중위 순회 (in-order traversal): 왼쪽 가지 → 현재 노드 → 오른쪽 가지

- 이진 탐색 트리를 중위 순회한다면 오름차순으로 방문하게 됨

```jsx
function inOrderTraversal(TreeNode node) {
	if (node !== null) {
		inOrderTraversal(node.left);
		visit(node);
		inOrderTraverasl(node.right);
	}
}
```

### 📍 전위 순회 (pre-order): 현재 노드 → 왼쪽 노드 → 오른쪽 노드

- 루트노드를 가장 먼저 방문

```jsx
function preOrderTraversal(TreeNode node) {
	if (node !== null) {
		visit(node);
		preOrderTraversal(node.left);
		preOrderTraversal(node.right);
	}
}
```

### 📍 후위 순회 (post-order): 왼쪽 노드 → 오른쪽 노드 → 현재 노드

- 루트노드를 가장 마지막에 방문

```jsx
function postOrderTraversal(TreeNode node) {
	if (node !== null) {
		postOrderTraversal(node.left);
		postOrderTraversal(node.right);
		visit(node);
	}
}
```

## ❄️ 이진 힙(최소힙과 최대힙)

---

### 📍 최소힙(min-heaps)?

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/5bdbffc8-e92d-4604-9bb4-52b996abe56e)

- 트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져 있다는 점에서 완전 이진 트리임
- 루트는 트리에서 가장 작은 원소
  - 각 노드의 원소가 자식들의 원소보다 작다
- 최대힙(max-heaps): 내림차순
- 핵심 연산 두 가지: insert, extract_min

### 📍 핵심연산 1) 삽입: insert

- 최소힙에 원소를 삽입할 때는 언제나 트리의 밑바닥에서부터 삽입을 시작
- 완전 트리의 속성에 위배되지 않게 새로운 원소는 밑바닥 가장 오른쪽 위치로 삽입됨
  - 그 다음에 새로 삽입된 원소가 제대로 된 자리를 찾을 때까지 부모 노드와 교환해 나감
- 힙에 있는 노드의 개수를 n이라 할 때 위의 연산은 $O(log n)$시간이 걸림

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/af006aec-5060-449b-9198-6f59facb830f)

### 📍 핵심연산 2) 최소 원소 뽑아내기: extract_min

- 최소힙에서 최소 원소를 찾는 것은 쉬운 일임
- 최소 원소는 언제나 가장 위에 놓임
- 최솟값을 어떻게 힙에서 제거하느냐가 까다로운 부분임
  - 최소원소를 제거한 후에 힙에 있는 가장 마지막 원소(밑바닥 가장 왼쪽에 위치한 원소)와 교환함
  - 그 다음 최소힙의 성질을 만족하도록, 해당 노드를 자식 노드와 교환해 나감으로써 밑으로 내보냄
  - 왼쪽 자식과 오른쪽 자식 중 누구와 교환해야 하나?
    - 원소의 값이 무엇이냐에 따라 달라짐
    - 최소 힙의 속성을 유지하기 위해선 더 작은 원소와 교환해 나가야 함
    - $O(log n)$시간이 걸림

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/15953a97-b73e-4a49-a0fe-5042c7dfebd1)

## ❄️ 트라이(접두사 트리): trie(prefix tree)

- n-차 트리의 변종
- 각 노드에 문자를 저장하는 자료구조
  - 트리를 아래쪽으로 순회하면 단어 하나가 나옴
- 널 노드(null node)라고 불리우는 \* 노드는 종종 단어의 끝을 나타냄
- 접두사를 빠르게 찾아보기 위한 아주 흔한 방식
  - 모든 언어를 트라이에 저장해놓는 방식
  - 해시테이블을 이용하면 주어진 문자열이 유효한지 아닌지 빠르게 확인할 수 있지만, 그 문자열이 어떤 유효한 단어의 접두사인지 확인할 수는 없음
  - 트라이를 이용하면 빠르게 확인할 수 있음
- 트라이는 길이가 K인 문자열이 주어졌을 때 O(K)시간에 해당 문자열이 유효한 접두사인지 확인할 수 있음

## ❄️ 그래프

- 노드 + 그 노드를 연결하는 간선(edge)를 하나로 모아놓은 것
- 방향성이 있을 수도 없을 수도 있음
- 여러 개의 고립된 부분 그래프로 구성될 수 있음
- 모든 정점 쌍간에 경로가 존재하는 그래프는? → 연결 그래프
- 사이클이 존재할 수도 있고 존재하지 않을 수도 있음
  - 사이클이 없는 그래프 = 비순환 그래프
- **트리?**
  - 그래프의 한 종류임
  - 사이클이 없는 하나의 연결 그래프

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/5361d84b-fde2-4387-bef0-8dfac112c85d)

### 📍 표현 방법1. 인접 리스트

- 모든 노드를 인접 리스트에 저장함
- 무방향 그래프에서 (a,b) 간선은 두 번 저장됨

```
0: 1
1: 2
2: 0, 3
3: 2
4: 6
5: 4
6: 5
```

### 📍 표현 방법2. 인접 행렬

- NxN boolean 행렬로 표현한 것
- 단점
  - 어떤 노드에 인접한 노드를 찾기 위해서는 모든 노드를 전부 순회해야 알 수 있음

![image](https://github.com/yeonju0110/algorithm-study/assets/97719273/2cf50a06-0918-484a-a189-b17fd1c5e744)

### 📍 그래프 탐색

- 일반적인 방법: 깊이 우선 탐색, 너비 우선 탐색

### 📍 깊이 우선 탐색(DFS)

- 모든 노드를 방문하고자 할 때 더 선호되는 편
- 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 함
- 장점
  - 간단한 재귀를 이용해 구현할 수 있으므로 좀 더 단순
  - 다른 인접 노드를 방문하기 전에 특정한 인접 노드를 깊이 있게 탐색해 볼 수 있음

```jsx
function search(Node root) {
	if (root === null) {
		return;
	}
	visit[root];
	root.visited = true;
	for each (Node n in root.adjacent) {
		if (n.visited === false) {
			search(n);
		}
	}
}
```

### 📍 너비 우선 탐색(BFS)

- 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때
- 큐(queue) 사용
  - 큐를 이용해서 반복적 형태로 구현하는 것이 가장 잘 동작함

```jsx
function search(Node root) {
	Queue queue = new Queue();
	root.marked = true;
	queue.enqueue(root); // 큐의 끝에 추가함

	while (!queue.isEmpty()) {
		Node r = queue.dequeue(); // 큐의 앞에서 뽑아냄
		visit(r);
		for each (Node n in r.adjacent) {
			if (n.marked === false) {
				n.marked = true;
				queue.enqueue(n);
			}
		}
	}
}
```

### 📍 양방향 탐색

- 출발지와 도착지 사이에 최단 경로를 찾을 때 사용됨
- 기본적으로 출발지와 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방식
